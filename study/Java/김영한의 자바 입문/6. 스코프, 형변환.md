# 스코프1 - 지역변수와 스코프
선언한 <u>**위치**에 따라 지역변수, 멤버변수(클래스 변수, 인스턴스 변수)와 같이 분류</u>됨.

지역이 바로 변수가 선언된 코드 블록 `{ }` 이다. 지역 변수는 자신이 선언된 코드 블록 안에서만 생존하고, 자신이 선언된 코드 블록을 벗어나면 제거된다. 이후에는 접근할 수 없다.

**Scope 1**
```java
package scope;  
  
public class Scope1 {  
    public static void main(String[] args) {  
        int m = 10; // m 생존 시작  
        if (true) {  
            int x = 20; // x 생존 시작  
            System.out.println("if m = " + m);  
            System.out.println("if x = " + x);  
        } // x 생존 종료  
        System.out.println("main x = " + x);  
        System.out.println("main m = " + m);  
    } // m 생존 종료  
}
```
![](https://i.imgur.com/vdJ6Ncc.png)
- `int m`
	- `int m` = `main( )`의 코드 블록안에서 선언되어 변수를 선언한 시점부터 `main( )` 코드 블록이 종료될 때까지 생존한다.
	- `if{ }` 블록 내부에서도 외부 블록에서 선언된 m에 접근할 수 있다. 쉽게 이야기해서 생존 범위만 맞으면 다 접근할 수 있다.
- `int x`
	- `int x`는 `if{ }`블록 안에서 선언되었다. 따라서 변수를 선언한 시점부터 `if{ }`의 코드 블록이 종료될 때까지 생존한다.
	- `if{ }` 내부에서는 자신의 범위에서 선언한 x에 당연히 접근할 수 없다.
	- `if{ }` 코드 블록이 끝나버리면 x는 제거된다. 따라서 더는 x에는 접근할 수 없게 된다. 따라서 이후 접근하면 `cannot find symbol`이라는 컴파일 오류가 발생한다.

정리하면 지역 변수는 본인의 코드 블록 안에서만 생존한다.<br>
자신의 코드 블록 안에서는 얼마든지 접근할 수 있지만 코드 블록을 벗어나면 제거되기 때문에 접근할 수 없다.

**이렇게 변수의 접근 가능한 범위를 스코프(Scope)라고 한다. **

```java
package scope;  
  
public class Scope2 {  
    public static void main(String[] args) {  
        int m = 10;  
        for (int i = 0; i < 2; i++) {  
            System.out.println("for m = " + m);  
            //블록 내에서 외부는 접근 가능하다.  
            System.out.println("for i = " + i);  
        } // i 생존 종료  
  
        System.out.println("main i = " + i);  
        System.out.println("main m = " + m);  
    }  
}
```
![](https://i.imgur.com/e28nzoU.png)

# 스코프 2 - 스코프 존재 이유
```java
package scope;  
  
public class Scope3_1 {  
    public static void main(String[] args) {  
        int m = 10;  
        int temp = 0;  // 임시변수
        if (m > 10) {  
            temp = m * 2;  
            System.out.println("temp = " + temp);  
        }  
        System.out.println("m = " + m);  
    }  
}
```
조건이 맞으면 변수 `m`의 값을 2배 증가해서 출력하는 코드다. 여기서 2배 증가한 값을 저장해주기 위해 임시 변수 `temp`를 사용했다. 그런데 이 코드는 좋은 코드로 보기 어렵다.

임시 변수 `temp`가 `main( )` 코드 블록에 선언되어 있다. 이런 경우 다음과 같은 문제가 발생한다.
- **비효율적인 메모리 사용**
- **코드 복잡성 증가**

```java
package scope;  
  
public class Scope3_2 {  
    public static void main(String[] args) {  
        int m = 10;  
  
        if (m > 10) {  
            int temp = 0;  
            temp = m * 2;  
            System.out.println("temp = " + temp);  
        }  
        System.out.println("m = " + m);  
    }  
}
```
이렇게 temp의 위치를 변경하였다.

#### while, for 문에서 스코프 관점으로 다시보기
```java
package loop;  
  
public class While2_1 {  
    public static void main(String[] args) {  
        int sum = 0;  
        int i = 1;  
        int endNum = 3;  
  
        while (i <= endNum) {  
            sum = sum + 1;  
            System.out.println("i = " + i + " sum = " + sum);  
            i++;  
        }  
    }  
}
```

```java
package loop;  
  
public class For2 {  
    public static void main(String[] args) {  
        int sum = 0;  
        int endNum = 3;  
        for (int i = 1; i <= endNum; i++) {  
            sum = sum + i;  
            System.out.println("i = " + i + ", sum = " + sum);  
        }  
    }  
}
```
변수의 스코프 관점에서 카운터 변수 i를 비교해보면
- `while문`의 경우 변수 `i`의 스코프가 `main( )` 메서드 전체가 된다. 반면 for문의 경우 i의 스코프가 `for`문 안으로 한정된다.
- 따라서 변수 `i`와 같이 `for`문 안에서만 사용되는 카운터 변수가 있다면 `while문` 보다는 `for`문을 사용해서 스코프의 범위를 제한하는 것이 메모리 사용과 유지보수 관점에서 더 좋다.

>[!note] 정리
> - 변수는 꼭 필요한 범위로 한정해서 사용하는 것이 좋다. 변수의 스코프는 꼭 필요한 곳으로 한정해서 사용하자. 메모리를 효율적으로 사용할 수 있고 더 유지보수하기 좋은 코드를 만들 수 있다.
>- **좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 <u>적절한 제약</u>이 있는 프로그램이다.**

# 형변환 1 - 자동 형변환
## 형변환
- 작은 범위에서 큰 범위로 당연히 값을 넣을 수 있다.
	- `int` -> `long` -> `double`
- 큰 범위에서 작은 범위는 다음과 같은 문제가 발생할 수 있다.
	- 소수점 버림
	- 오버플로우

```java
package casting;  
  
public class Casting1 {  
    public static void main(String[] args) {  
        int intValue = 10;  
        long longValue;  
        double doubleValue;  
  
        longValue = intValue; // int->long  
        System.out.println("longValue = " + longValue);  
  
        doubleValue = intValue; // ing->double  
        System.out.println("doubleValue = " + doubleValue);  
  
        doubleValue = 20L;// long->double  
        System.out.println("doubleValue = " + doubleValue);  
    }  
}
```
![](https://i.imgur.com/omiHgiq.png)

- 자바는 **기본적으로 같은 타입에 값을 대입**할 수 있다.
- int -> long을 비교하면 long이 int보다 더 큰 숫자 범위를 표헌한다. 작은 범위 숫자 타입에선 큰 범위 숫자 타입에 대입을 하면 문제가 되지 않는다. 이런 경우까지 오류가 발생하면 개발이 너무 불편할 것이다...
- long -> double 의 경우에도 double은 부동 소수점을 사용하기 때문에 더 큰 숫자 범위를 표현한다. 따라서 대입할 수 있다.
- 작은 범위에서 큰 범위로의 대입은 자바 언어에서 허용한다.

## 자동 형변환
하지만 결국 대입하는 형(타입)을 맞춰야 하기 때문에 개념적으로는 다음과 같이 동작한다.
```java
//intValue = 10
doubleValue = intValue
doubleValue = (double) intValue // 형 맞추기
doubleValue = (double ) 10 // 변수 값 읽기
doubleValue = 10.0 // 형 변환
```

이렇게 `(double)` 과 같이 적어주면 `int` 형이 `double` 형으로 형이 변한다. 이렇게 형이 변경되는 것을 형변환이라 한다. 작은 범위 숫자타입에서 큰 범위 숫자 타입으로의 대입은 개발자가 이렇게 직접 형변환 하지 않아도 된다. 이런 과정이 자동으로 일어나기 때문에 **자동 형변환**, **묵시적 형변환** 이라고 한다.