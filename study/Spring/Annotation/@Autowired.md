#Annotation 
[[4. 스프링 빈과 의존관계]]
[[7. 의존관계 자동 주입]]

# Autowired
필요한 **의존 객체의 "타입"에 해당하는 빈을 찾아 주입**힌다.
- 생성자
- setter
- 필드
의 경우 Autowired 를 사용할 수 있다.

> Autowired는 기본값이 Ture이기 때문에 주입할 대상을 못찾으면 애플리케이션 구동에 실패한다.


# Autowired를 사용할 경우
## Constructor Dependency Injection
- 생성자에 의존성 주입을 받고자 하는 필드를 나열하는 방법.
- 권고되는 방법의 하나.
### 장점
1. 필수적으로 사용해야 하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제.
2. Spring 4.3 부터는 생성자가 하나인 경우 @Autowired 를 사용하지 않아도 됨.
3. Circular Dependency / 순환 참조2 의존성을 알아 차릴 수 있음.
4. 생성자에 점차 많은 의존성이 추가 될 경우, 리팩토링 시점을 감지 할 수 있음.
5. 의존성 주입 대상 필드를 **final로 불변 객체 선언**할 수 있음.
6. 테스트 코드 작성시 생성자를 통해 의존성 주입이 용이함.
### 단점
1. 어쩔 수 없는 순환참조는 생성자 주입으로 해결하기 어려움.
	1. 이런 경우 나머지 주입 방법 중에 하나를 사용.
	2. 가급적 순환참조가 발생하지 않도록 하는 것이 중요하다.

## Setter Dependency Injection
- setter 메소드에 @Autowired를 선언하여 주입받는 방법.
### 장점
1. 의존성이 선택적으로 필요한 경우에 사용할 수 있음.
2. 생성자에 모든 의존성을 기술하면 과도하게 복잡해질 수 있는데 선택적으로 나눠 주입 할 수 있게 부담을 덜어줌.
3. 생성자 주입 방법과 Setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용할 수 있음.
### 단점
- 의존성 주입 대상 필드가 **final 선언할 수 없다.**

## Field Dependency Injection
- member field에 @Autowired 선언하여 주입받는 방법.
### 장점
- 가장 간단한 선언 방식이다.
### 단점
1. 의존 관계가 눈에 잘 보이지 않아 추상적이고
2. 의존성 관계가 과도하게 복잡해질 수 있다.
	- 반대로 **생성자 주입 / Setter 주입**은 의존성을 명확하게 커뮤니케이션 함.
3. SRP / 단일 책임 원칙에 반하는 안티패턴이 됨.
4. DI Container와 강한 결합을 가져 외부 사용이 용이하지 않음.
	- 단위 테스트 시 의존성 주입이 용이하지 않다.
5. 의존성 주입 대상 필드가 **final 선언할 수 없다.**