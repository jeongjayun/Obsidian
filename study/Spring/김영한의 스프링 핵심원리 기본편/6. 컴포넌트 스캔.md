> https://www.inflearn.com/course/스프링-핵심-원리-기본편
# 컴포넌트 스캔과 의존관계 자동 주입 시작하기
- 지금까지 스프링 빈을 등록할 때는 자바 코드의 `@Bean`이나 XML의 `<bean>`을 통해서 설정 정보에 직접 등록할 스프링 빈을 나열했다.
- 예제에서는 몇개 없었지만 실무에서는 이렇게 등록해야 할 스프링 빈이 수십, 수백개가 되면 일일이 등록하기도 귀찮고, 설정 정보도 커지고, 누락하는 문제도 발생한다.
- 그래서 **스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공**한다.
- 또 **의존관계도 자동으로 주입**하는 [[../Annotation/@Autowired|@Autowired]] 기능도 제공한다.

![](https://i.imgur.com/RSRAIif.png)

- 컴포넌트 스캔을 사용하려면 `@ComponentScan`을 설정 정보에 붙여주면 사용할 수 있다.
- 기존의 `AppConfig`와 다르게 `@Bean` 을 등록한 클래스가 없다.

```java
package hello.core;  
  
import hello.core.discount.DiscountPolicy;  
import hello.core.discount.RateDiscountPolicy;  
import hello.core.member.*;  
import hello.core.order.OrderService;  
import hello.core.order.OrderServiceImpl;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.context.annotation.Primary;  
  
@Configuration // 설정정보  
public class AppConfig {  
  
    @Bean  
    public MemberService memberService() {  
        System.out.println("call AppConfig.memberService");  
        return new MemberServiceImpl(memberRepository());  
    }  

    @Bean  
    public MemberRepository memberRepository() {  
        System.out.println("call AppConfig.memberRepository");  
        return new MemoryMemberRepository();  
    }  
  
    @Bean  
    public OrderService orderService(){  
        System.out.println("call AppConfig.orderService");  
        return new OrderServiceImpl(memberRepository(), discountPolicy());}  
  
    @Bean  
    public DiscountPolicy discountPolicy(){  
        System.out.println("call AppConfig.discountPolicy");  
//        return new FixDiscountPolicy();  
        return new RateDiscountPolicy();  
    }  
}
```

>[!note] 참고
>컴포넌트 스캔을 사용하면 `@Configuration`이 붙은 설정 정보도 자동으로 등록되기 때문에 `AppConfig, TestConfig` 등 앞서 만들어 두었던 설정 정보도 함께 등록되고 실행된다. 그래서 `exludeFilters`를 이용하여 설정정보는 컴포넌트 스캔 대상에서 제외했다.<br>
><u>보통 설정 정보를 스캔 대상에서 제외하지 않지만</u> 기존 예제 코드를 최대한 남기고 유지하기 위해서 이 방법을 선택 했다.

컴포넌트 스캔은 이름 그대로 `@Component` 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다. `@Component` 를 붙여주자.

**MemoryMemberRepository @Component 추가**
**RateDiscountPolicy @Component 추가**
**MemberServiceImple**

/*basePackages = "hello.core.member",  
//탐색할 패키지의 시작 위치를 정해줄 수 있다.  
basePackageClasses = AutoAppConfig.class,  
default로 아무 설정도 하지 않으면 ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작위치가 된다.  
  
** 권장하는 방법 **패키지 위치를 지정하지 않고 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것이다.  
최근 스프링 부트도 이 방법을 기본으로 제공한다.  
  
컴포넌트 스캔 기본 대상  
@Component : 컴포넌트 스캔에서 사용  
@Controller : 스프링 MVC 컨트롤러  
@Service : 스프링 비즈니스 로직 사용  
@Repository : 스프링 데이터 접근 계층에서 사용  
@Configuration : 스프링 설정정보에서 사용  
=> 어노테이션은 상속관계라는 게 없음.  
*/

//ComponentScan : @Component 어노테이션 붙은 클래스를 모두 자동으로 스캔해서 스프링 빈으로 등록함.  
//위처럼 필터를 걸어줄 수 있지만 실무에서는 필터 거는 일은 없다.  
//Component + Autowired 까지 함께 씀

# 탐색 위치와 기본 스캔 대상
# 필터
# 중복 등록과 충돌
컴포넌트 스캔에서 같은 빈 이름을 등록하면?

## 자동 빈 등록 vs 자동 빈 등록
- 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링에서 오류 발생시킨다.
	- `ConflictingBeanDefinitionException` 예외 발생
## 수동 빈 등록 vs 자동 빈 등록
```java
@Component
public class MemoryMemberRepository implements MemberRepository{

}
```

```java
@Configuration
@ComponentScan(excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class))
public class AutoAppConfig {
	@Bean (name = "memoryMemberRepository")
	public MemberRepository memberRepository() {
		return new MemoryMemberRepository();
		}
}
```

이렇게 되면 **수동 빈 등록이 우선권을 가져** <span style="background:#fff88f">자동 빈을 오버라이딩</span> 한다. 

### 수동 빈 등록 시 남는 로그
`Overriding bean definition for bean 'memoryMemberRepository' with a different definition. : replacing'

개발자가 의도적으로 이런 결과를 기대했다면 자동보다는 수동이 우선권을 가지는 것이 좋지만 현실은 **개발자의 의도와 다르게** 여러 설정들이 꼬여서 만들어지는 경우가 많다. **그러면 정말 잡기 어려운 버그가 만들어진다.**

![](https://i.imgur.com/dcO0gh8.png)

최근 스프링 부트는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 변경하였다.

## 수동 빈 등록, 자동 빈 등록 오류 시 스프링 부트 에러
`properties` 파일에서 다음을 추가해주면 된다.
```
spring.main.allow-bean-definition-overriding=true
```

- ture : 오버라이딩 가능
- false : 오버라이딩 안됨

